.. _cpp-DGFlow:

**********************************************************
DGFlow.h
**********************************************************
.. default-domain:: cpp

.. py:currentmodule:: mod
.. cpp:namespace:: mod


Class ``DGFlow``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: DGFlow
    

    A :class:`DGFlow` object represents a flow model on a given derivation graph.
    A model consists of a set of extensions with the Base extension modelling the edge flow and input/output flow.


Synopsis
^^^^^^^^

.. code-block:: c++
    
    class DGFlow : public std::enable_shared_from_this<DGFlow> {
        DGFlow(const DGFlow&) = delete;
        DGFlow &operator=(const DGFlow&) = delete;
        DGFlow(DGFlow&&) = delete;
        DGFlow &operator=(DGFlow&&) = delete;
    private:
        DGFlow(std::unique_ptr<lib::Flow::FlowBase> base);
    public:
        ~DGFlow();
        friend std::ostream &operator<<(std::ostream &s, const DGFlow &dgFlow);
        unsigned int getId() const;
        std::shared_ptr<DG> getDG() const;
        lib::Flow::FlowBase &getBase();
        const lib::Flow::FlowBase &getBase() const;
    public: // base extension
        void addSource(std::shared_ptr<Graph> g);
        void addSink(std::shared_ptr<Graph> g);
        void setAllowHyperLoops(bool value);
        bool getAllowHyperLoops() const;
        void setAllowReverse(bool value);
        bool getAllowReverse() const;
        void setAllowIOReverse(bool value);
        bool getAllowIOReverse() const;
        void setRelaxed(bool value);
        bool getRelaxed() const;
    public: // transit
        class TransitProxy {
            TransitProxy(const TransitProxy&) = delete;
            TransitProxy &operator=(const TransitProxy&) = delete;
            TransitProxy(TransitProxy&&) = delete;
            TransitProxy &operator=(TransitProxy&&) = delete;
        private:
            friend class DGFlow;
            TransitProxy(DGFlow &dgFlow);
        public:
            void printGraph(std::shared_ptr<Graph> g) const;
            void printExpanded() const;
        private:
            DGFlow &dgFlow;
        };
        TransitProxy transit;
    public: // overall autocatalysis
        class OverallAutocatalysisProxy {
            OverallAutocatalysisProxy(const OverallAutocatalysisProxy&) = delete;
            OverallAutocatalysisProxy &operator=(const OverallAutocatalysisProxy&) = delete;
            OverallAutocatalysisProxy(OverallAutocatalysisProxy&&) = delete;
            OverallAutocatalysisProxy &operator=(OverallAutocatalysisProxy&&) = delete;
        private:
            friend class DGFlow;
            OverallAutocatalysisProxy(DGFlow &dgFlow);
        public:
            void enable();
            void setForceExistence(bool value);
            bool getForceExistence() const;
            void setStrictTransit(bool value);
            bool getStrictTransit() const;
            void setBFSExclusive(bool value);
            bool getBFSExclusive() const;
        private:
            DGFlow &dgFlow;
        };
        OverallAutocatalysisProxy overallAutocatalysis;
    public: // overall catalysis
        class OverallCatalysisProxy {
            OverallCatalysisProxy(const OverallCatalysisProxy&) = delete;
            OverallCatalysisProxy &operator=(const OverallCatalysisProxy&) = delete;
            OverallCatalysisProxy(OverallCatalysisProxy&&) = delete;
            OverallCatalysisProxy &operator=(OverallCatalysisProxy&&) = delete;
        private:
            friend class DGFlow;
            OverallCatalysisProxy(DGFlow &dgFlow);
        public:
            void enable();
            void setForceExistence(bool value);
            bool getForceExistence() const;
            void setStrictTransit(bool value);
            bool getStrictTransit() const;
        private:
            DGFlow &dgFlow;
        };
        OverallCatalysisProxy overallCatalysis;
    public: // common
        void addConstraint(const DGFlowAux::LinConstraint &constraint);
        void setVertexFilter(std::shared_ptr<Function<bool(std::shared_ptr<Graph>)> > vFilter);
        void setObjectiveFunction(DGFlowAux::LinExp func);
        void listModel() const;
    public:
        void setSolver(const DGFlowAux::Solver &solver);
        std::string dump() const;
        void calc();
    public:
        DGFlowAux::SolutionSet getSolutions() const;
    private:
        struct Pimpl;
        std::unique_ptr<Pimpl> p;
    public:
        static std::shared_ptr<DGFlow> make(std::shared_ptr<DG> dg);
        static std::shared_ptr<DGFlow> flowDump(std::shared_ptr<DG> dg, const std::string &file);
    };

Details
^^^^^^^

.. cpp:namespace:: mod

.. cpp:namespace-push:: DGFlow

.. function:: unsigned int getId() const

    :returns: the instance identifier for the object.
.. function:: std::shared_ptr<DG> getDG() const

    :returns: the underlying derivation graph.
.. function:: lib::Flow::FlowBase &getBase()
              const lib::Flow::FlowBase &getBase() const

    :returns: the internal data structures of the flow model.
.. function:: void addSource(std::shared_ptr<Graph> g)

    Add the vertex represented by ``g`` as a possible source.
    The graph ``g`` must be part of the underlying derivation graph.

    :throws: :class:`LogicError` if the specification is locked or if ``g`` is not part of the underling derivation graph.
.. function:: void addSink(std::shared_ptr<Graph> g)

    Add the vertex represented by ``g`` as a possible sink.
    The graph ``g`` must be part of the underlying derivation graph.

    :throws: :class:`LogicError` if the specification is locked or if ``g`` is not part of the underling derivation graph.
.. function:: void setAllowHyperLoops(bool value)
              bool getAllowHyperLoops() const

    Control or query whether or not flow is allowed through loop hyper-edges.
    I.e., hyperedges with identical left and right side.

    :throws: (only set) :class:`LogicError` if the specification is locked.

    :note: This setting may be changed when certain modules are enabled.
.. function:: void setAllowReverse(bool value)
              bool getAllowReverse() const

    Control or query whether or not flow in solutions may go through
    one derivation and then directly afterwards the reverse derivation.

    :throws: (only set) :class:`LogicError` if the model is locked.

    :note: This setting may be modified when certain modules are enabled.
.. function:: void setAllowIOReverse(bool value)
              bool getAllowIOReverse() const

    Control or query whether or not flow in solutions may go through
    an input edge and directly afterwards through the corresponding output edge.

    :throws: (only set) :class:`LogicError` if the model is locked.

    :note: This setting may be modified when certain modules are enabled.
.. function:: void setRelaxed(bool value)
              bool getRelaxed() const

    Controls whether the core variables are integer or continuous.
    The default is ``False``, meaning integer. Using the relaxed model significantly
    changes the meaning of solutions, and many features may break.
    This feature is only here to provide an easy way to emulated flux balance analysis.
.. member:: TransitProxy transit

    The transit extension of the flow model.
.. member:: OverallAutocatalysisProxy overallAutocatalysis

    The overall autocatalysis extension of the flow model.
.. member:: OverallCatalysisProxy overallCatalysis

    The overall catalysis extension of the flow model.
.. function:: void addConstraint(const DGFlowAux::LinConstraint &constraint)

    Add the given linear constraint to the model.

    :throws: :class:`LogicError` if the model is locked.
.. function:: void setVertexFilter(std::shared_ptr<Function<bool(std::shared_ptr<Graph>)> > vFilter)

    Set a filter indicating the vertices which should be considered part of the model.
    This not only disables flow through the vertices but also removes the vertices from considerations in some algorithms.

    :throws: :class:`LogicError` if the model is locked.
.. function:: void setObjectiveFunction(DGFlowAux::LinExp func)

    Set the objective function used when finding solutions.

    :throws: :class:`LogicError` if the model is locked.
.. function:: void listModel() const

    List all settings of the model.
.. function:: void setSolver(const DGFlowAux::Solver &solver)

    Set which solver to use, e.g., a simple optimization with only the optimal solution, or enumeration solving for finding many solutions.
.. function:: std::string dump() const

    Dump all model settings and all solutions found to a file. This file can be loaded in again.

    :returns: the filename with the dumped model.
    :throws: :class:`LogicError` if calculation has not been done.
.. function:: calc()

    Find solutions using the current solver.

    :throws: :class:`LogicError` if calculation has already been done.
.. function:: DGFlowAux::SolutionSet getSolutions() const

    :returns: the found solutions for the model.
    :throws: :class:`LogicError` if calculation has not been done.
.. function:: static std::shared_ptr<DGFlow> make(std::shared_ptr<DG> dg)

    :returns: a clean flow model for the given derivation graph.
    :throws: :class:`LogicError` if the given derivation graph has not been calculated.
.. function:: static std::shared_ptr<DGFlow> flowDump(std::shared_ptr<DG> dg, const std::string &file)

    :returns: a flow model (possibly with solutions) corresponding to the model stored in the given file.
        The given derivation graph must match the derivation graph originally used to create the dump.
    :throws: :class:`InputError` on bad data or when the given derivation graph does not match the data.

.. cpp:namespace:: mod


Class ``DGFlow::TransitProxy``
---------------------------------------------------------------

.. class:: DGFlow::TransitProxy


    This class provides access to the transit extension of a flow model.

    .. function:: void printGraph(std::shared_ptr<Graph> g) const

        Print the expanded network of the vertex represented by the graph ``g``.

        :throws: :class:`LogicError` if the given graph does not belong to the underlying derivation graph.


Class ``DGFlow::OverallAutocatalysisProxy``
---------------------------------------------------------------

.. class:: DGFlow::OverallAutocatalysisProxy


    This class provides access to the extension for overall autocatalysis of a flow model.

    .. function:: void enable()

        Enable the extension. This will also enable the transit extension and configure it to
        disallow direct flow through inverse edges, both internal and input/output.

        :throws: :class:`LogicError` if the model is locked.
    .. function:: void setForceExistence(bool value)
                  bool getForceExistence() const

        Control or query whether or not a solution must be overall autocatalytic.
    .. function:: void setStrictTransit(bool value)
                  bool getStrictTransit() const

        Control or query whether transit flow in overall autocatalytic vertices is restricted or not.
    .. function:: void setBFSExclusive(bool value)
                  bool getBFSExclusive() const

        Control or query whether or not vertices must be exclusively overall autocatalytic,
        as determined by breadth-first marking.


Class ``DGFlow::OverallCatalysisProxy``
---------------------------------------------------------------

.. class:: DGFlow::OverallCatalysisProxy


    This class provides access to the extension for overall catalysis of a flow model.

    .. function:: void enable()

        Enable the extension. This will also enable the transit extension and configure it to
        disallow direct flow through inverse edges, both internal and input/output.

        :throws: :class:`LogicError` if the model is locked.
    .. function:: void setForceExistence(bool value)
                  bool getForceExistence() const

        Control or query whether or not a solution must be overall catalytic.
    .. function:: void setStrictTransit(bool value)
                  bool getStrictTransit() const

        Control or query whether transit flow in overall catalytic vertices is restricted or not.



Linear Expressions and Constraints
----------------------------------

.. class:: DGFlowAux::LinExp

.. class:: DGFlowAux::LinConstraint

Linear expressions and constraints can be implicitly created from variable specifiers and operators,
meaning one rarely need to instantiate them explicitly.
However creating the zero-expression might sometimes be useful (e.g., in a sum expression)
and can be done simply with the expression ``DGFlowAux::LinExp()``.

A variable specifier is a representation of either a single ILP variable or a sum of ILP variables.
The addition, multiplication and division operators are overloaded for variable specifiers and
linear expressions such that expressions can be written in the natural manner.

The operators ``<=``, ``==`` and ``>=`` are overloaded on linear expressions to make the creation of
linear constraints easier. However, one argument to the operator must be a linear expression while
the other argument must be a number.

Variable Specifiers
--------------------

All variable specifiers are defined in the namespace ``DGFlowVar``. See :ref:`dgFlowCommon` for an overview of the specifiers.


Class ``DGFlowAux::SequenceQuery``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: DGFlowAux::SequenceQuery
    

    Representation of a query for a flow sequence.


Synopsis
^^^^^^^^

.. code-block:: c++
    
    struct SequenceQuery {
        SequenceQuery();
        void setMultiplicity(unsigned int multiplicity);
        unsigned int getMultiplicity() const;
        void setBorrow(std::shared_ptr<Graph> g, unsigned int count);
        unsigned int getBorrow(std::shared_ptr<Graph> g) const;
        void setConstrainRouting(bool v);
        bool getConstrainRouting() const;
    public:
        lib::Flow::SequenceQuery getQuery(std::shared_ptr<DG> dg) const;
    private:
        unsigned int multiplicity;
        std::unordered_map<std::shared_ptr<mod::Graph>, unsigned int> borrow;
        bool constrainRouting;
    };

Details
^^^^^^^

.. cpp:namespace:: mod

.. cpp:namespace-push:: DGFlowAux::SequenceQuery

.. function:: SequenceQuery()

    Construct a query with multiplicity 1 and no borrowing.
.. function:: void setMultiplicity(unsigned int multiplicity)
              unsigned int getMultiplicity() const

    Set/get the multiplicity of the query. It must be at least 1.
    :throws: (set) :class:`mod::LogicError` if the multiplicity is 0.
.. function:: void setBorrow(std::shared_ptr<Graph> g, unsigned int count)
              unsigned int getBorrow(std::shared_ptr<Graph> g) const

    Set/get the amount of flow allowed to be borrowed at the vertex represented by the graph.
.. function:: void setConstrainRouting(bool v)
              bool getConstrainRouting() const

    Set/get whether routing edges must conform to the flow. Setting this to ``false`` may give sequences violating flow constraints.

.. cpp:namespace:: mod


Class ``DGFlowAux::Solution``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: DGFlowAux::Solution
    

    An object of this class represents a solution for a specific flow model.


Synopsis
^^^^^^^^

.. code-block:: c++
    
    class Solution {
        friend class SolutionSet;
        Solution(std::shared_ptr<DGFlow> dgFlow, unsigned int id);
    public:
        lib::Flow::Solution makeSolution() const;
    public:
        unsigned int getId() const;
        std::shared_ptr<mod::DGFlow> getDGFlow() const;
        double eval(const LinExp &exp) const;
        void print(const DGPrintData &data, const Printer &printer) const;
        void haxListDerivations() const;
        // :throws: :class:`mod::LogicError` if at least one graph in the query does not represent a vertex in the underlying derivation graph.
        bool hasSequence(const SequenceQuery &query) const;
        // :throws: :class:`mod::LogicError` if at least one graph in the query does not represent a vertex in the underlying derivation graph.
        bool hasDAG(const SequenceQuery &query) const;
        // :throws: :class:`mod::LogicError` if at least one graph in the query does not represent a vertex in the underlying derivation graph.
        // :throws: :class:`LogicError` if the sequence does not exist.
        DGTransition::Sequence getSequence(const SequenceQuery &query) const;
        // :throws: :class:`mod::LogicError` if at least one graph in the query does not represent a vertex in the underlying derivation graph.
        // :throws: :class:`LogicError` if the DAG does not exist.
        DGTransition::DAG getDAG(const SequenceQuery &query) const;
        // :throws: :class:`LogicError` if the two solutions are not on the same derivation graph.
        bool equal(const Solution &other, const LinExp &vars) const;
        // object equality, not the same as equal
        friend bool operator==(const Solution &lhs, const Solution &rhs);
    private:
        std::shared_ptr<DGFlow> dgFlow;
        unsigned int id;
    };

Details
^^^^^^^

.. cpp:namespace:: mod

.. cpp:namespace-push:: DGFlowAux::Solution

.. function:: unsigned int getId() const

    :returns: an id for the solution which is unique among all solutions from the parent :class:`DGFlow` object.
.. function:: std::shared_ptr<DGFlow> getDGFlow() const

    :returns: the flow model that produced this solution.
.. function:: double eval(const LinExp &exp) const

    :returns: the value of the given linear expression evaluated on the solution.
.. function:: void print(const DGPrintData &data, const Printer &printer) const

    Print the solution using the settings in the given printer.
    :throws: :class:`LogicError` if the given print data does not belong to the underlying derivation graph.
.. function:: void haxListDerivations() const

    List the solution in more human readable form.
    Don't expect this function to stay in this form.

.. cpp:namespace:: mod


Class ``DGFlowAux::SolutionSet``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: DGFlowAux::SolutionSet
    

    An object of this class represents the solutions for a specific flow model.


Synopsis
^^^^^^^^

.. code-block:: c++
    
    struct SolutionSet {
        struct const_iterator {
            using difference_type = std::size_t;
            using value_type = Solution;
            using reference = Solution;
            using iterator_category = std::forward_iterator_tag;
            using pointer = void;
        private:
            friend class SolutionSet;
            const_iterator(const SolutionSet &set, unsigned int id);
        public:
            bool operator!=(const_iterator other) const;
            bool operator==(const_iterator other) const;
            const_iterator operator++();
            const_iterator operator++(int);
            Solution operator*() const;
        private:
            const SolutionSet &set;
            unsigned int id;
        };
        using iterator = const_iterator;
    public:
        SolutionSet(std::shared_ptr<DGFlow> dgFlow);
        std::shared_ptr<DGFlow> getDGFlow() const;
        friend std::ostream &operator<<(std::ostream &s, const SolutionSet &set);
        void list() const;
        unsigned int size() const;
        void print(const DGPrintData &data, const Printer &printer) const;
        void printVectors() const;
        const_iterator begin() const;
        const_iterator end() const;
        Solution operator[](unsigned int i) const;
    private:
        Solution makeSolution(unsigned int id) const;
    private:
        std::shared_ptr<DGFlow> dgFlow;
        unsigned int numSolutions;
    };

Details
^^^^^^^

.. cpp:namespace:: mod

.. cpp:namespace-push:: DGFlowAux::SolutionSet

.. function:: SolutionSet(std::shared_ptr<DGFlow> dgFlow)

    Construct a representation of the solutions for the given flow model.
.. function:: std::shared_ptr<DGFlow> getDGFlow()

    :returns: the flow model that produced these solutions.
.. function:: void list() const

    List overall information about each solution.
.. function:: unsigned int size() const

    :returns: the number of solutions in the flow model.
.. function:: void print(const DGPrintData &data, const Printer &printer) const

    Print all solutions using the given flow printer.
.. function:: void printVectors() const

    (Deprecated) Print some solution data in an old format.
    Use the :func:`DGFlow::dump` instead.
.. function:: const_iterator begin() const

    :returns: an iterator to the first solution.
.. function:: const_iterator end() const

    :returns: an iterator to after the last solution.
.. function:: Solution operator[](unsigned int i) const

    :returns: the solution at the given index.
    :throws: :class:`LogicError` if the index is out of bounds.

.. cpp:namespace:: mod


Class ``DGFlowAux::Solver``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: DGFlowAux::Solver
    

    Base class for all available solvers.

Class ``DGFlowAux::Solve``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: DGFlowAux::Solve : DGFlowAux::Solver
    

    The basic solver, finding only a single optimal solution.

Class ``DGFlowAux::Enumerate``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: DGFlowAux::Enumerate : DGFlowAux::Solver
    

    (deprecated) A solver for enumerating solutions, based on populate.
    Solutions are supposed to be enumerated in order of optimality,
    but this is not always the case with this solver.

    .. member:: int absGap = 1 << 30

        The maximum allowed distance to the optimal solution.
    .. member:: unsigned int maxNumSolutions = 1 << 30

        The maximum number of solutions to find.

Class ``DGFlowAux::EnumerateBy``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: DGFlowAux::EnumerateBy : DGFlowAux::Solver
    

    A solver for enumerating solutions, based on a tree search on the domain of a subset of the variables.
    Solutions are are enumerated in order of optimality.

    .. member:: int absGap = 1 << 30

        The maximum allowed distance to the optimal solution.
    .. member:: unsigned int maxNumSolutions = 1 << 30

        The maximum number of solutions to find.
    .. member:: boost::optional<LinExp> enumerationVarSpecifier

        A linear expression for specifying which variables' domains will be used for enumeration.
        Coefficients have no meaning. As default all non-transit edge variables, including I/O edges, are used.
    .. member:: std::unordered_set<std::shared_ptr<Graph> > transitEnumeration

        A set of graphs specifying a set of vertices in the derivation graph.
        For the specified vertices the transit edges will participate in the enumeration.

Class ``DGFlowAux::Populate``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: DGFlowAux::Populate : DGFlowAux::Solver
    

    A solver for finding multiple solutions, based on the populate mechanic in CPLEX.

    .. member:: int absGap = 1 << 30

        The maximum allowed distance to the optimal solution.
    .. member:: unsigned int maxNumSolutions = 1 << 30

        The maximum number of solutions to find.

Class ``DGFlowAux::Printer``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: DGFlowAux::Printer
    

    An object of this class represents options for printing flow solutions.


Synopsis
^^^^^^^^

.. code-block:: c++
    
    class Printer {
        Printer(const Printer&) = delete;
        Printer &operator=(const Printer&) = delete;
        Printer(Printer&&) = delete;
        Printer &operator=(Printer&&) = delete;
    public:
        Printer();
        ~Printer();
        DGPrinter &getDGPrinter();
        const DGPrinter &getDGPrinter() const;
        lib::IO::DGFlow::Write::Printer &getPrinter() const;
        void setWithFlowLabels(bool value);
        bool getWithFlowLabels() const;
        void pushInOutEdgeLabel(std::function<std::string(std::shared_ptr<Graph>, std::shared_ptr<DG>, bool) > f);
        void popInOutEdgeLabel();
        void setPrintUnfiltered(bool value);
        bool getPrintUnfiltered() const;
        void setPrintFiltered(bool value);
        bool getPrintFiltered() const;
        void setColourUnfiltered(bool value);
        bool getColourUnfiltered() const;
    private:
        std::unique_ptr<DGPrinter> dgPrinter;
        std::unique_ptr<lib::IO::DGFlow::Write::Printer> printer;
    };

Details
^^^^^^^

.. cpp:namespace:: mod

.. cpp:namespace-push:: DGFlowAux::Printer

.. function:: DGPrinter &getDGPrinter()
              const DGPrinter &getDGPrinter() const

    :returns: a reference to the :class:`DGPrinter` used when printing flow solutions.
.. function: void setWithFlowLabels(bool value)
             bool getWithFlowLabels() const

    Control whether or not a flow label is appended to each hyperedge label (see also :func:`DGPrinter::pushEdgeLabel`). 
.. function:: void pushInOutEdgeLabel(std::function<std::string(std::shared_ptr<Graph>, std::shared_ptr<DG>, bool)> f)

    Add another function for in-/out-edge labelling.
    The result of this function is appended to each label using the edge label separator
    of the underlying :class:`DGPrinter`.
    The last argument given to the function is ``true`` for the in-edge, and ``false`` for the out-edge.
.. function:: void popInOutEdgeLabel()

    Remove the last pushed in/out edge labelling function.
.. function:: void setPrintUnfiltered(bool value)
              bool getPrintUnfiltered() const

    Control whether or not the unfiltered version of a solution is printed.
.. function:: void setPrintFiltered(bool value)
              bool getPrintFiltered() const

    Control whether or not the filtered version of a solution is printed.
.. function:: void setColourUnfiltered(bool value)
              bool getColourUnfiltered() const

    Control whether or not the vertices and edges with non-zero flow are coloured in the unfiltered version of solutions.

.. cpp:namespace:: mod

