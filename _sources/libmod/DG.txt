.. _cpp-DG:

**********************************************************
DG.h
**********************************************************
.. default-domain:: cpp

.. py:currentmodule:: mod
.. cpp:namespace:: mod


Class ``DerivationRef``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: DerivationRef
    

    The class represents a reference to a derivation in a derivation graph.
    A reference may be invalid.


Synopsis
^^^^^^^^

.. code-block:: c++
    
    class DerivationRef {
        friend class lib::DG::Hyper;
        DerivationRef(unsigned int id, std::shared_ptr<DG> dg);
    public:
        DerivationRef();
        friend std::ostream &operator<<(std::ostream &s, const DerivationRef &d);
        unsigned int getId() const;
        std::shared_ptr<DG> getDG() const;
        bool isValid() const;
        Derivation operator*() const;
        void print(const GraphPrinter &printer, const std::string &matchColour) const;
        bool operator<(const DerivationRef &other) const;
        friend bool operator==(const DerivationRef &a, const DerivationRef &b) {
            return a.id == b.id && a.dg == b.dg;
        }
    private:
        unsigned int id;
        std::shared_ptr<DG> dg;
    };

Details
^^^^^^^

.. cpp:namespace:: mod

.. cpp:namespace-push:: DerivationRef

.. function:: DerivationRef()

    Constructor for an invalid reference.
.. function:: unsigned int getId() const

    :returns: the id of the derivation.
.. function:: std::shared_ptr<DG> getDG() const

    :returns: the derivation graph the reference is pointing into.
.. function:: bool isValid() const

    :returns: ``true`` iff the reference is valid.
.. function:: Derivation operator*() const

    :returns: the derivation represented by the reference.
.. function:: void print(const GraphPrinter &printer, const std::string &matchColour) const

    Print the derivation pointed to by the derivation reference.
    All possible Double-Pushout diagrams for the derivation are printed.
    The ``matchColour`` must be a valid colour for TikZ, which is applied to the rule
    and its image in the bottom span.

.. cpp:namespace:: mod


Class ``DG``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: DG
    

    The main derivation graph class. A derivation graph is a directed hypergraph
    :math:`\mathcal{H} = (V, E)`.
    Each vertex is annotated with a graph, and each hyperedge is annotated with a transformation rule.
    A derivation graph can either be calculated from a strategy or loaded from external data.


Synopsis
^^^^^^^^

.. code-block:: c++
    
    struct DG {
        DG(const DG&) = delete;
        DG &operator=(const DG&) = delete;
    public:
        class HyperEdge;
        class VertexIterator;
        class EdgeIterator;
        class InEdgeIterator;
        class OutEdgeIterator;
        class InEdgeRange;
        class OutEdgeRange;
        class SourceRange;
        class TargetRange;
        class SourceIterator;
        class TargetIterator;
        class RuleRange;
        class Vertex {
            friend class HyperEdge;
            friend class VertexIterator;
            friend class SourceIterator;
            friend class TargetIterator;
            Vertex(std::shared_ptr<DG> g, std::size_t vId);
        public:
            Vertex();
            friend std::ostream &operator<<(std::ostream &s, const Vertex &v);
            friend bool operator==(const Vertex &v1, const Vertex &v2);
            friend bool operator!=(const Vertex &v1, const Vertex &v2);
            std::size_t getId() const;
            std::shared_ptr<DG> getDG() const;
            std::size_t inDegree() const;
            InEdgeRange inEdges() const;
            std::size_t outDegree() const;
            OutEdgeRange outEdges() const;
            std::shared_ptr<Graph> getGraph() const;
        private:
            std::shared_ptr<DG> g;
            std::size_t vId;
        };
        class HyperEdge {
            friend class EdgeIterator;
            friend class InEdgeIterator;
            friend class OutEdgeIterator;
            HyperEdge(std::shared_ptr<DG> g, std::size_t eId);
        public:
            HyperEdge();
            friend std::ostream &operator<<(std::ostream &s, const HyperEdge &e);
            friend bool operator==(const HyperEdge &e1, const HyperEdge &e2);
            friend bool operator!=(const HyperEdge &e1, const HyperEdge &e2);
            std::size_t getId() const;
            std::shared_ptr<DG> getDG() const;
            std::size_t numSources() const;
            SourceRange sources() const;
            std::size_t numTargets() const;
            TargetRange targets() const;
            RuleRange rules() const;
        private:
            std::shared_ptr<DG> g;
            std::size_t eId;
        };
    public: // VertexList
        class VertexIterator : public boost::iterator_facade<VertexIterator, Vertex, std::forward_iterator_tag, Vertex> {
            friend class DG;
            VertexIterator(std::shared_ptr<DG> g);
        public:
            VertexIterator();
        private:
            friend class boost::iterator_core_access;
            Vertex dereference() const;
            bool equal(const VertexIterator &iter) const;
            void increment();
        private:
            std::shared_ptr<DG> g;
            std::size_t vId;
        };
        struct VertexRange {
            using iterator = VertexIterator;
            using const_iterator = iterator;
        private:
            friend class DG;
            VertexRange(std::shared_ptr<DG> g);
        public:
            VertexIterator begin() const;
            VertexIterator end() const;
        private:
            std::shared_ptr<DG> g;
        };
    public: // EdgeList
        class EdgeIterator : public boost::iterator_facade<EdgeIterator, HyperEdge, std::forward_iterator_tag, HyperEdge> {
            friend class DG;
            EdgeIterator(std::shared_ptr<DG> g);
        public:
            EdgeIterator();
        private:
            friend class boost::iterator_core_access;
            HyperEdge dereference() const;
            bool equal(const EdgeIterator &iter) const;
            void increment();
        private:
            std::shared_ptr<DG> g;
            std::size_t eId;
        };
        struct EdgeRange {
            using iterator = EdgeIterator;
            using const_iterator = iterator;
        private:
            friend class DG;
            EdgeRange(std::shared_ptr<DG> g);
        public:
            EdgeIterator begin() const;
            EdgeIterator end() const;
        private:
            std::shared_ptr<DG> g;
        };
    public: // Bidirectional
        class InEdgeIterator : public boost::iterator_facade<InEdgeIterator, HyperEdge, std::forward_iterator_tag, HyperEdge> {
            friend class InEdgeRange;
            InEdgeIterator(std::shared_ptr<DG> g, std::size_t vId);
        public:
            InEdgeIterator();
        private:
            friend class boost::iterator_core_access;
            HyperEdge dereference() const;
            bool equal(const InEdgeIterator &iter) const;
            void increment();
        private:
            std::shared_ptr<DG> g;
            std::size_t vId, eId;
        };
        struct InEdgeRange {
            using iterator = InEdgeIterator;
            using const_iterator = iterator;
        private:
            friend class Vertex;
            InEdgeRange(std::shared_ptr<DG> g, std::size_t vId);
        public:
            InEdgeIterator begin() const;
            InEdgeIterator end() const;
        private:
            std::shared_ptr<DG> g;
            std::size_t vId;
        };
        class OutEdgeIterator : public boost::iterator_facade<OutEdgeIterator, HyperEdge, std::forward_iterator_tag, HyperEdge> {
            friend class OutEdgeRange;
            OutEdgeIterator(std::shared_ptr<DG> g, std::size_t vId);
        public:
            OutEdgeIterator();
        private:
            friend class boost::iterator_core_access;
            HyperEdge dereference() const;
            bool equal(const OutEdgeIterator &iter) const;
            void increment();
        private:
            std::shared_ptr<DG> g;
            std::size_t vId, eId;
        };
        struct OutEdgeRange {
            using iterator = OutEdgeIterator;
            using const_iterator = iterator;
        private:
            friend class Vertex;
            OutEdgeRange(std::shared_ptr<DG> g, std::size_t vId);
        public:
            OutEdgeIterator begin() const;
            OutEdgeIterator end() const;
        private:
            std::shared_ptr<DG> g;
            std::size_t vId;
        };
    public: // HyperBidirectional (sources and targets of hyperedges)
        class SourceIterator : public boost::iterator_facade<SourceIterator, Vertex, std::forward_iterator_tag, Vertex> {
            friend class SourceRange;
            SourceIterator(std::shared_ptr<DG> g, std::size_t eId);
        public:
            SourceIterator();
        private:
            friend class boost::iterator_core_access;
            Vertex dereference() const;
            bool equal(const SourceIterator &iter) const;
            void increment();
        private:
            std::shared_ptr<DG> g;
            std::size_t eId, vId;
        };
        struct SourceRange {
            using iterator = SourceIterator;
            using const_iterator = iterator;
        private:
            friend class HyperEdge;
            SourceRange(std::shared_ptr<DG> g, std::size_t eId);
        public:
            SourceIterator begin() const;
            SourceIterator end() const;
        private:
            std::shared_ptr<DG> g;
            std::size_t eId;
        };
        class TargetIterator : public boost::iterator_facade<TargetIterator, Vertex, std::forward_iterator_tag, Vertex> {
            friend class TargetRange;
            TargetIterator(std::shared_ptr<DG> g, std::size_t eId);
        public:
            TargetIterator();
        private:
            friend class boost::iterator_core_access;
            Vertex dereference() const;
            bool equal(const TargetIterator &iter) const;
            void increment();
        private:
            std::shared_ptr<DG> g;
            std::size_t eId, vId;
        };
        struct TargetRange {
            using iterator = TargetIterator;
            using const_iterator = iterator;
        private:
            friend class HyperEdge;
            TargetRange(std::shared_ptr<DG> g, std::size_t eId);
        public:
            TargetIterator begin() const;
            TargetIterator end() const;
        private:
            std::shared_ptr<DG> g;
            std::size_t eId;
        };
    public:
        class RuleIterator : public boost::iterator_facade<RuleIterator, std::shared_ptr<Rule>, std::forward_iterator_tag, std::shared_ptr<Rule> > {
            friend class RuleRange;
            RuleIterator(std::shared_ptr<DG> g, std::size_t eId);
        public:
            RuleIterator();
        private:
            friend class boost::iterator_core_access;
            std::shared_ptr<Rule> dereference() const;
            bool equal(const RuleIterator &iter) const;
            void increment();
        private:
            std::shared_ptr<DG> g;
            std::size_t eId, i;
        };
        struct RuleRange {
            using iterator = RuleIterator;
            using const_iterator = iterator;
        private:
            friend class HyperEdge;
            RuleRange(std::shared_ptr<DG> g, std::size_t eId);
        public:
            RuleIterator begin() const;
            RuleIterator end() const;
        private:
            std::shared_ptr<DG> g;
            std::size_t eId;
        };
    public:
        struct DerivationRefRange {
            struct const_iterator {
                using difference_type = std::size_t;
                using value_type = DerivationRef;
                using reference = DerivationRef;
                using iterator_category = std::forward_iterator_tag;
                using pointer = void;
            private:
                friend class DerivationRefRange;
                const_iterator(const DerivationRefRange &range, unsigned int id);
            public:
                bool operator!=(const const_iterator &other) const;
                bool operator==(const const_iterator &other) const;
                const_iterator operator++();
                const_iterator operator++(int);
                DerivationRef operator*() const;
            private:
                const DerivationRefRange &range;
                unsigned int id;
            };
            using iterator = const_iterator;
        private:
            friend class DG;
            DerivationRefRange(unsigned int firstId, unsigned int endId,
                    std::function<unsigned int(unsigned int) > next,
                    std::function<DerivationRef(unsigned int) > dereference)
            : firstId(firstId), endId(endId), next(next), dereference(dereference) { }
        public:
            const_iterator begin() const;
            const_iterator end() const;
        private:
            unsigned int firstId, endId;
            std::function<unsigned int(unsigned int) > next;
            std::function<DerivationRef(unsigned int) > dereference;
        };
    private:
        DG(std::unique_ptr<lib::DG::NonHyper> dg);
    public:
        ~DG();
        unsigned int getId() const;
        friend std::ostream &operator<<(std::ostream &s, const DG &dg);
        const lib::DG::NonHyper &getNonHyper() const;
        const lib::DG::Hyper &getHyper() const;
    public: // hypergraph interface
        std::size_t numVertices() const;
        VertexRange vertices() const;
        std::size_t numEdges() const;
        EdgeRange edges() const;
    public:
        void calc();
        const std::set<std::shared_ptr<Graph>, GraphLess> &getGraphDatabase() const;
        const std::vector<std::shared_ptr<Graph> > &getVertexGraphs() const;
        const std::vector<std::shared_ptr<Graph> > &getProducts() const;
        void print(const DGPrintData &data, const DGPrinter &printer) const;
        std::string dump() const;
        void printMatrix() const;
        DerivationRef getDerivationRef(const std::vector<std::shared_ptr<Graph> > &educts, const std::vector<std::shared_ptr<Graph> > &products) const;
        DerivationRefRange derivations() const;
        DerivationRefRange inDerivations(std::shared_ptr<Graph> g) const;
        DerivationRefRange outDerivations(std::shared_ptr<Graph> g) const;
        void list() const;
        void listStats() const;
        void listIncidence(const std::shared_ptr<Graph> g) const;
        // :throws: :class:`LogicError` if the DG has not been calculated or if the DG is not created from strategies.
        std::vector<std::shared_ptr<Graph> > getStratOutputSubset() const;
    private:
        struct Pimpl;
        std::unique_ptr<Pimpl> p;
    public:
        static std::shared_ptr<DG> derivations(const std::vector<Derivation> &derivations);
        static std::shared_ptr<DG> abstract(const std::string &specification);
        static std::shared_ptr<DG> sbml(const std::string &file);
        static std::shared_ptr<DG> ruleComp(const std::vector<std::shared_ptr<Graph> > &graphs,
                std::shared_ptr<DGStrat> strategy);
        static std::shared_ptr<DG> dumpImport(const std::vector<std::shared_ptr<Graph> > &graphs, const std::vector<std::shared_ptr<Rule> > &rules, const std::string &file);
        static void diff(std::shared_ptr<DG> dg1, std::shared_ptr<DG> dg2);
    };

Details
^^^^^^^

.. cpp:namespace:: mod

.. cpp:namespace-push:: DG

.. function:: unsigned int getId() const

    :returns: the instance identifier for the object.
.. function:: const lib::DG::NonHyper &getNonHyper() const
              const lib::DG::Hyper &getHyper() const

    :returns: the internal data structures of the derivation graph.
.. function:: std::size_t numVertices() const

    :returns: the number of vertices in the derivation graph.
.. function:: VertexRange vertices() const

    :returns: a range of all vertices in the derivation graph.
.. function:: std::size_t numEdges() const

    :returns: the number of edges in the derivation graph.
.. function:: EdgeRange edges() const

    :returns: a range of all edges in the derivation graph.
.. function:: void calc()

     Compute the derivation graph.

.. function:: const std::set<std::shared_ptr<Graph>, GraphLess> &getGraphDatabase() const

    :returns: the set of all graphs created by the derivation graph,
        and all graphs given when constructed.
.. function:: const std::vector<std::shared_ptr<Graph> > &getVertexGraphs() const

    :returns: the list of all graphs actually in the derivation graph.
.. function:: const std::vector<std::shared_ptr<Graph> > &getProducts() const

    :returns: the list of new graphs discovered by the derivation graph.
.. function:: void print(const DGPrintData &data, const DGPrinter &printer) const

    Print the derivation graph in style of a hypergraph.

    :throws: :class:`LogicError` if the print data is not for this DG.
.. function:: std::string dump() const

    Exports the derivation graph to a text file, which can be importetet.

    :returns: the name of the file with the exported data.
    :throws: :class:`LogicError` if the DG has not been calculated.
.. function:: void printMatrix() const

    (Deprecated) Exports some of the derivation graph data as sparse matrix.
    Use the dump function instead.

    :throws: :class:`LogicError` if the DG has not been calculated.
.. function:: DerivationRef getDerivationRef(const std::vector<std::shared_ptr<Graph> > &educts, const std::vector<std::shared_ptr<Graph> > &products) const

    :returns: a reference to a derivation with the left side being ``educts`` and right side being ``products``.
        If no such derivation exists in the derivation graph then the reference is invalid.
    :throws: :class:`LogicError` if the DG has not been calculated.
.. function:: DerivationRefRange derivations() const

    :returns: an iterator range of references to all derivations in this DG.
    :throws: :class:`LogicError` if the DG has not been calculated.
.. function:: DerivationRefRange inDerivations(std::shared_ptr<Graph> g) const

    :returns: an iterator range of references to all derivations going in to the vertex corresponding to ``g``.
        A derivation reference is in the range as many times as the vertex is a member of the head-multiset of that derivation.
    :throws: :class:`LogicError` if the DG has not been calculated.
.. function:: DerivationRefRange outDerivations(std::shared_ptr<Graph> g) const

    :returns: an iterator range of references to all derivations going out of the vertex corresponding to ``g``.
        A derivation reference is in the range as many times as the vertex is a member of the tail-multiset of that derivation.
    :throws: :class:`LogicError` if the DG has not been calculated.
.. function:: void list() const

    Output information on the calculation of the derivation graph.
    For strategy-based calculations, this outputs the expression tree.
.. function:: void listStats() const

    Output various stats of the derivation graph.

    :throws: :class:`LogicError` if the DG has not been calculated.
.. function:: void listIncidence(const std::shared_ptr<Graph> g) const

    Output the adjacent derivations of the vertex corresponding to the given graph.

    :throws: :class:`LogicError` if the DG has not been calculated.
.. function:: static std::shared_ptr<DG> derivations(const std::vector<Derivation> &derivations)

    Create a derivation graph from a list of :class:`Derivation`.
.. function:: static std::shared_ptr<DG> abstract(const std::string &specification)

    Create a derivation graph from an abstract description according to the following grammar.

    .. productionlist::
        description: `derivation` { `derivation` }
        derivation: `side` ("->" | "<=>") `side`
         side: `term` { "+" `term` }
        term: [ `unsignedInt` ] `identifier`

    :throws: :class:`InputError` on bad input.
.. function:: static std::shared_ptr<DG> sbml(const std::string &file)

    Load a derivation graph from an SBML file.

    :throws: :class:`InputError` on bad input.
.. function:: static std::shared_ptr<DG> ruleComp(const std::vector<std::shared_ptr<Graph> > &graphs, \
              std::shared_ptr<DGStrat> strategy)

    Initialize a derivation graph with a :cpp:class:`DGStrat` and an initial graph database.
    Any derived graph isomorphic to a given graph is replaced by the given graph.
.. function:: static std::shared_ptr<DG> dumpImport(const std::vector<std::shared_ptr<Graph> > &graphs, const std::vector<std::shared_ptr<Rule> > &rules, const std::string &file)

    Load a derivation graph dump. Any graph in the dump which is isomorphic to a given graph is replaced by the given graph.
    The same procedure is done for the rules, however only using the name of the rule for comparison.

    :throws: :class:`InputError` on bad input.
.. function:: static void diff(std::shared_ptr<DG> dg1, std::shared_ptr<DG> dg2)

    Compare two derivation graphs and lists the difference.
    This is not a general isomorphism check; two vertices are equal if they have
    the same graph attached. Edges are equal if the head and tail sets are equal
    and if the attached rule is the same.

.. cpp:namespace:: mod


Class ``DG::Vertex``
---------------------------------------------------------------

.. class:: DG::Vertex


    A descriptor of either a vertex in a graph, or a null vertex.

    .. function:: Vertex()

        Constructs a null descriptor.
    .. function:: std::size_t getId() const

        :returns: the index of the vertex. It will be in the range :math:`[0, numVertices + numEdges[`.
        :throws: :cpp:class:`LogicError` if it is a null descriptor.
    .. function:: std::shared_ptr<DG> getDG() const

        :returns: the derivation graph the vertex belongs to.
        :throws: :cpp:class:`LogicError` if it is a null descriptor.
    .. function:: std::size_t inDegree() const

        :returns: the in-degree of the vertex, including multiplicity of target multisets.
        :throws: :cpp:class:`LogicError` if it is a null descriptor.
    .. function:: InEdgeRange inEdges() const

        :returns: a range of in-hyperedges for this vertex.
        :throws: :cpp:class:`LogicError` if it is a null descriptor.
    .. function:: std::size_t getOutDegree() const

        :returns: the out-degree of the vertex, including multiplicity of source multisets.
        :throws: :cpp:class:`LogicError` if it is a null descriptor.
    .. function:: OutEdgeRange outEdges() const

        :returns: a range of out-hyperedges for this vertex.
        :throws: :cpp:class:`LogicError` if it is a null descriptor.
    .. function:: std::shared_ptr<Graph> &getGraph() const

        :returns: the graph label of the vertex.
        :throws: :cpp:class:`LogicError` if it is a null descriptor.


Class ``DG::HyperEdge``
---------------------------------------------------------------

.. class:: DG::HyperEdge


    A descriptor of either a hyperedge in a derivation graph, or a null edge.

    .. function:: HyperEdge()

        Constructs a null descriptor.
    .. function:: std::size_t getId() const

        :returns: the index of the hyperedge. It will be in the range :math:`[0, numVertices + numEdges[`.
        :throws: :cpp:class:`LogicError` if it is a null descriptor.
    .. function:: std::shared_ptr<DG> getDG() const

        :returns: the derivation graph the hyperedge belongs to.
        :throws: :cpp:class:`LogicError` if it is a null descriptor.
    .. function:: std::size_t numSources() const

        :returns: the number of sources of the hyperedge.
        :throws: :cpp:class:`LogicError` if it is a null descriptor.
    .. function:: SourceRange sources() const

        :returns: the sources of the hyperedge.
        :throws: :cpp:class:`LogicError` if it is a null descriptor.
    .. function:: std::size_t numTargets() const

        :returns: the number of targets of the hyperedge.
        :throws: :cpp:class:`LogicError` if it is a null descriptor.
    .. function:: TargetRange targets() const

        :returns: the targets of the hyperedge.
        :throws: :cpp:class:`LogicError` if it is a null descriptor.
    .. function:: RuleRange rules() const

        :returns: a range of the rules associated with the hyperedge.
        :throws: :cpp:class:`LogicError` if it is a null descriptor.


Class ``DG::VertexIterator``
---------------------------------------------------------------

.. class:: DG::VertexIterator


    An iterator for traversing all vertices in a derivation graph.
    It models a forward iterator.

    .. function:: VertexIterator()

        Construct a past-the-end iterator.


Class ``DG::VertexRange``
---------------------------------------------------------------

.. class:: DG::VertexRange


    A range of all vertices in a derivation graph.



Class ``DG::EdgeIterator``
---------------------------------------------------------------

.. class:: DG::EdgeIterator


    An iterator for traversing all edges in a graph.
    It models a forward iterator.

    .. function:: EdgeIterator()

        Construct a past-the-end iterator.


Class ``DG::EdgeRange``
---------------------------------------------------------------

.. class:: DG::EdgeRange


    A range of all edges in a derivation graph.



Class ``DG::InEdgeIterator``
---------------------------------------------------------------

.. class:: DG::InEdgeIterator


    An iterator for enumerating all in-edges of a vertex.
    It models a forward iterator.

    .. function:: InEdgeIterator()

        Construct a past-the-end iterator.


Class ``DG::InEdgeRange``
---------------------------------------------------------------

.. class:: DG::InEdgeRange


    A range of all in-edges of a vertex.



Class ``DG::OutEdgeIterator``
---------------------------------------------------------------

.. class:: DG::OutEdgeIterator


    An iterator for enumerating all out-edges of a vertex.
    It models a forward iterator.

    .. function:: OutEdgeIterator()

        Construct a past-the-end iterator.


Class ``DG::OutEdgeRange``
---------------------------------------------------------------

.. class:: DG::OutEdgeRange


    A range of all out-edges of a vertex.



Class ``DG::SourceIterator``
---------------------------------------------------------------

.. class:: DG::SourceIterator


    An iterator for enumerating all sources of a hyperedge.
    It models a forward iterator.

    .. function:: SourceIterator()

        Construct a past-the-end iterator.


Class ``DG::SourceRange``
---------------------------------------------------------------

.. class:: DG::SourceRange


    A range of all sources of a hyperedge.



Class ``DG::TargetIterator``
---------------------------------------------------------------

.. class:: DG::TargetIterator


    An iterator for enumerating all targets of a hyperedge.
    It models a forward iterator.

    .. function:: TargetIterator()

        Construct a past-the-end iterator.


Class ``DG::TargetRange``
---------------------------------------------------------------

.. class:: DG::TargetRange


    A range of all sources of a hyperedge.



Class ``DG::RuleIterator``
---------------------------------------------------------------

.. class:: DG::RuleIterator


    An iterator for enumerating all rules of a hyperedge.
    It models a forward iterator.

    .. function:: RuleIterator()

        Construct a past-the-end iterator.


Class ``DG::RuleRange``
---------------------------------------------------------------

.. class:: DG::RuleRange


    A range of all rules of a hyperedge.



Class ``DG::DerivationRefRange``
---------------------------------------------------------------

.. class:: DG::DerivationRefRange


    This class represents a range of derivation references.

    .. function:: const_iterator begin() const

        :returns: the begin iterator for the range of derivation references.
    .. function:: const_iterator end() const

        :returns: the end iterator for the range of derivation references.



Class ``DGPrintData``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: DGPrintData
    

    This class is used to hold extra data about how a specific derivation graph
    is visualised.


Synopsis
^^^^^^^^

.. code-block:: c++
    
    struct DGPrintData {
        DGPrintData(std::shared_ptr<DG> dg);
        DGPrintData(const DGPrintData &other);
        DGPrintData(DGPrintData &&other);
        ~DGPrintData();
        lib::IO::DG::Write::Data &getData();
        lib::IO::DG::Write::Data &getData() const;
        std::shared_ptr<DG> getDG() const;
        void makeDuplicate(DerivationRef dRef, unsigned int eDup);
        void removeDuplicate(DerivationRef dRef, unsigned int eDup);
        void reconnectTail(DerivationRef dRef, unsigned int eDup, std::shared_ptr<Graph> g, unsigned int vDupTar); // TODO: make overload with explicit source
        void reconnectHead(DerivationRef dRef, unsigned int eDup, std::shared_ptr<Graph> g, unsigned int vDupTar); // TODO: make overload with explicit source
    private:
        std::shared_ptr<DG> dg;
        std::unique_ptr<lib::IO::DG::Write::Data> data;
    };

Details
^^^^^^^

.. cpp:namespace:: mod

.. cpp:namespace-push:: DGPrintData

.. function:: DGPrintData(std::shared_ptr<DG> dg)

    Construct a data object where all derivations have a single version, 0, connected to version 0 of all heads and tails.
.. function:: std::shared_ptr<DG> getDG() const

    :returns: the derivation graph the object holds data for.
.. function:: void makeDuplicate(DerivationRef dRef, unsigned int eDup)

    Create another version of the given derivation and give it the given duplicate number.
.. function:: void removeDuplicate(DerivationRef dRef, unsigned int eDup)

    Remove the version of the given derivation with the given duplicate number.
.. function:: void reconnectTail(DerivationRef dRef, unsigned int eDup, std::shared_ptr<Graph> g, unsigned int vDupTar)

    Reconnect an arbitrary version of the tail specified by the given graph in the derivation duplicate given.
.. function:: void reconnectHead(DerivationRef dRef, unsigned int eDup, std::shared_ptr<Graph> g, unsigned int vDupTar)

    Reconnect an arbitrary version of the head specified by the given graph in the derivation duplicate given.

.. cpp:namespace:: mod


Class ``DGPrinter``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: DGPrinter
    

    This class is used to configure how derivation graphs are visualised,
    how much is visualised and which extra properties are printed.


Synopsis
^^^^^^^^

.. code-block:: c++
    
    struct DGPrinter {
        DGPrinter();
        DGPrinter(const DGPrinter&) = delete;
        DGPrinter &operator=(const DGPrinter&) = delete;
        ~DGPrinter();
        lib::IO::DG::Write::Printer &getPrinter() const;
        GraphPrinter &getGraphPrinter();
        const GraphPrinter &getGraphPrinter() const;
        void setWithShortcutEdges(bool value);
        bool getWithShortcutEdges() const;
        void setWithGraphImages(bool value);
        bool getWithGraphImages() const;
        void setLabelsAsLatexMath(bool value);
        bool getLabelsAsLatexMath() const;
        void pushVertexVisible(std::function<bool(std::shared_ptr<Graph>, std::shared_ptr<DG>) > f);
        void popVertexVisible();
        void pushEdgeVisible(std::function<bool(DerivationRef) > f);
        void popEdgeVisible();
        void setWithShortcutEdgesAfterVisibility(bool value);
        bool getWithShortcutEdgesAfterVisibility() const;
        void setVertexLabelSep(std::string sep);
        const std::string &getVertexLabelSep();
        void setEdgeLabelSep(std::string sep);
        const std::string &getEdgeLabelSep();
        void pushVertexLabel(std::function<std::string(std::shared_ptr<Graph>, std::shared_ptr<DG>) > f);
        void popVertexLabel();
        void pushEdgeLabel(std::function<std::string(DerivationRef) > f);
        void popEdgeLabel();
        void setWithGraphName(bool value);
        bool getWithGraphName() const;
        void setWithRuleName(bool value);
        bool getWithRuleName() const;
        void setWithRuleId(bool value);
        bool getWithRuleId() const;
        void pushVertexColour(std::function<std::string(std::shared_ptr<Graph>, std::shared_ptr<DG>) > f, bool extendToEdges);
        void popVertexColour();
        void pushEdgeColour(std::function<std::string(DerivationRef) > f);
        void popEdgeColour();
    private:
        std::unique_ptr<GraphPrinter> graphPrinter;
        std::unique_ptr<lib::IO::DG::Write::Printer> printer;
    };

Details
^^^^^^^

.. cpp:namespace:: mod

.. cpp:namespace-push:: DGPrinter

.. function:: GraphPrinter &getGraphPrinter()
              const GraphPrinter &getGraphPrinter() const

    :returns: a reference to the :class:`GraphPrinter` used for graphs in vertices of the DG.
.. function:: void setWithShortcutEdges(bool value)
              bool getWithShortcutEdges() const

    Control whether or not hyperedges :math:`(T, H)` with :math:`|T| = |H| = 1`
    are printed as a simple arrow without the usual rectangle.
.. function::     void setWithGraphImages(bool value)
                bool getWithGraphImages() const

    Control whether or not each vertex is printed with a image of its graph in it.
.. function:: void setLabelsAsLatexMath(bool value)
              bool getLabelsAsLatexMath() const

    Control whether or not labels on vertices and hyperedges are put inline :math:`\LaTeX` math.
    Specifically, a label ``label`` is written as ``$\mathrm{label'}$``, with ``label'`` being
    ``label`` with all space characters escaped.
.. function:: void pushVertexVisible(std::function<bool(std::shared_ptr<Graph>, std::shared_ptr<DG>)> f)

    Add another function controlling the visibility of vertices.
    All visibility functions must return ``true`` for a vertex to be visible.
.. function:: void popVertexVisible()

    Remove the last pushed vertex visibility function.
.. function:: void pushEdgeVisible(std::function<bool(DerivationRef) > f)

    Add another function controlling the visibility of hyperedges.
    All visibility functions must return ``true`` for a hyperedge to be visible.
.. function:: void popEdgeVisible()

    Remove the last pushed hyperedge visibility function.
.. function:: void setWithShortcutEdgesAfterVisibility(bool value)
              bool getWithShortcutEdgesAfterVisibility() const

    Control whether or not hyperedges are depicted as simple arrows when all but 1 head and tail are hidden.
.. function:: void setVertexLabelSep(std::string sep)
              const std::string &getVertexLabelSep()

    Set/get the string used as separator between each part of each vertex label.
.. function:: void setEdgeLabelSep(std::string sep)
              const std::string &getEdgeLabelSep()

    Set/get the string used as separator between each part of each edge label.
.. function:: void pushVertexLabel(std::function<std::string(std::shared_ptr<Graph>, std::shared_ptr<DG>)> f)

    Add another function for vertex labelling. The result of this function is appended to each label.
.. function:: void popVertexLabel()

    Remove the last pushed vertex labelling function.
.. function:: void pushEdgeLabel(std::function<std::string(DerivationRef)> f)

    Add another function for edge labelling. The result of this function is appended to each label.
.. function:: void popEdgeLabel()

    Remove the last pushed edge labelling function.
.. function:: void setWithGraphName(bool value)
              bool getWithGraphName() const

    Control whether or not graph names are appended to the vertex labels (see also :func:`pushVertexLabel`).
.. function:: void setWithRuleName(bool value)
              bool getWithRuleName() const

    Control whether or not rules names are appended to the edge labels (see also :func:`pushEdgeLabel`).
.. function:: void setWithRuleId(bool value)
              bool getWithRuleId() const

    Control whether or not rules IDs are appended to the edge labels (see also :func:`pushEdgeLabel`).
.. function:: void pushVertexColour(std::function<std::string(std::shared_ptr<Graph>, std::shared_ptr<DG>)> f, bool extendToEdges)

    Add another function for colouring vertices. The final colour of a vertex is the result of the first colour function returning a non-empty string.
    The functions are evaluated in the order they are pushed and the resulting string is used directly as a colour in Tikz.
    A hyperedge is also coloured if at least one head and one tail *can* be coloured with a colour for which ``extendToEdges`` is ``true``.
    In this case, the hyperedge (and a subset of the head and tail connectors) is coloured with the first applicable colour.
    The edge extension of vertex colour takes lower precedence than explicitly added hyperedge colouring functions.
.. function:: void popVertexColour()

    Remove the last pushed vertex colouring function.
.. function:: void pushEdgeColour(std::function<std::string(DerivationRef)> f)

    Add another function for colouring hyperedges. The final colour of a hyperedge (and all of its head and tail connectors) is the result of the
    first colour function returning a non-empty string.
.. function:: void popEdgeColour()

    Remove the last pushed hyperedge colouring function.

.. cpp:namespace:: mod

