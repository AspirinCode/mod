.. _cpp-RC:

**********************************************************
RC.h
**********************************************************
.. default-domain:: cpp

.. py:currentmodule:: mod
.. cpp:namespace:: mod

This file contains the core functionality for composing rules and creating rules from graphs.

Class ``RCEvaluator``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: RCEvaluator
    

    This class can evaluate rule composition expressions. During evaluation an expression graph is recorded.

    The expression graph is a directed hypergraph :math:`(V, E)`, with each vertex representing a rule.
    Each edge represent all compositions calculated for a unique input. That is every edge :math:`e\in E` is on the form
    :math:`((u, v), R_e)` with :math:`(u, v)\in V\times V` as an *ordered* pair of rules and :math:`R_e\subseteq V` is the set
    of all resulting rules found.

    The graph is visualised as a bipartite graph with point-shaped vertices representing the hyperedges. The in-edges to these
    hyperedge vertices are labelled with 1 and 2.


Synopsis
^^^^^^^^

.. code-block:: c++
    
    class RCEvaluator {
        RCEvaluator(const std::unordered_set<std::shared_ptr<Rule> > &database);
        RCEvaluator(const RCEvaluator&) = delete;
        RCEvaluator &operator=(const RCEvaluator&) = delete;
        RCEvaluator(RCEvaluator&&) = delete;
        RCEvaluator &operator=(RCEvaluator&&) = delete;
    public:
        ~RCEvaluator();
        const std::unordered_set<std::shared_ptr<Rule> > &getRuleDatabase() const;
        const std::unordered_set<std::shared_ptr<Rule> > &getProducts() const;
        std::unordered_set<std::shared_ptr<Rule> > eval(const RCExp::Expression &exp);
        void print() const;
    private:
        struct Pimpl;
        std::unique_ptr<Pimpl> p;
    public:
        static std::shared_ptr<RCEvaluator> create(const std::unordered_set<std::shared_ptr<Rule> > &database);
    };

Details
^^^^^^^

.. cpp:namespace:: mod

.. cpp:namespace-push:: RCEvaluator

.. function:: const std::unordered_set<std::shared_ptr<Rule> > &getRuleDatabase() const

    :returns: the set of unique rules known by the evaluator.
.. function:: const std::unordered_set<std::shared_ptr<Rule> > &getProducts() const

    :returns: the set of unique rules this evaluator has constructed.
.. function:: std::unordered_set<std::shared_ptr<Rule> > eval(const RCExp::Expression &exp)

    Evaluates a rule composition expression. Any created rule is replaced by a rule in the database if they are isomorphic.

    :returns: the result of the expression.
.. function:: void print() const

    Print the graph representing all expressions evaluated so far.
.. function:: static std::shared_ptr<RCEvaluator> create(const std::unordered_set<std::shared_ptr<Rule> > &database)

    :returns: a new instance of an evaluator with its database initialised with the given rules.

    .. note:: The caller is responsible for ensuring the given rules are unique.

.. cpp:namespace:: mod

RCExp
---------------------------

In this namespace the data structures and operators for representing rule composition expressions are defined.
An expression, ``RCExp``, can be evaluated through the method ``RCEvaluator::eval``. The result of an expression
is a set of rules.


Class ``RCExp::Union``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: RCExp::Union
    

    Return the union of the subexpressions. I.e., flatten the subresult lists into a single list.


Synopsis
^^^^^^^^

.. code-block:: c++
    
    struct Union {
        Union(std::vector<Expression> exps);
        friend std::ostream &operator<<(std::ostream &s, const Union &par);
        const std::vector<Expression> &getExpressions() const;
    private:
        std::vector<Expression> exps;
    };

Class ``RCExp::Bind``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: RCExp::Bind
    

    Return the singleton list with the rule :math:`(\emptyset, \emptyset, G)` for the given graph :math:`G`.


Synopsis
^^^^^^^^

.. code-block:: c++
    
    struct Bind {
        Bind(std::shared_ptr<Graph> g);
        friend std::ostream &operator<<(std::ostream &s, const Bind &b);
        std::shared_ptr<Graph> getGraph() const;
    private:
        std::shared_ptr<Graph> g;
    };

Class ``RCExp::Id``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: RCExp::Id
    

    Return the singleton list with the rule :math:`(G, G, G)` for the given graph :math:`G`.


Synopsis
^^^^^^^^

.. code-block:: c++
    
    struct Id {
        Id(std::shared_ptr<Graph> g);
        friend std::ostream &operator<<(std::ostream &s, const Id &i);
        std::shared_ptr<Graph> getGraph() const;
    private:
        std::shared_ptr<Graph> g;
    };

Class ``RCExp::Unbind``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: RCExp::Unbind
    

    Return the singleton list with the rule :math:`(G, \emptyset, \emptyset)` for the given graph :math:`G`.


Synopsis
^^^^^^^^

.. code-block:: c++
    
    struct Unbind {
        Unbind(std::shared_ptr<Graph> g);
        friend std::ostream &operator<<(std::ostream &s, const Unbind &u);
        std::shared_ptr<Graph> getGraph() const;
    private:
        std::shared_ptr<Graph> g;
    };

Class ``RCExp::Expression``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: RCExp::Expression
    

    A generic rule composition expression.


Synopsis
^^^^^^^^

.. code-block:: c++
    
    struct Expression {
        Expression(std::shared_ptr<Rule> r);
        Expression(Union u);
        Expression(Bind bind);
        Expression(Id id);
        Expression(Unbind unbind);
        Expression(ComposeCommon compose);
        Expression(ComposeParallel compose);
        Expression(ComposeSub compose);
        Expression(ComposeSuper compose);
        template<typename Visitor>
        typename Visitor::result_type applyVisitor(Visitor visitor) const {
            return boost::apply_visitor(visitor, data);
        }
        friend std::ostream &operator<<(std::ostream &s, const Expression &exp);
    private:
        boost::variant<std::shared_ptr<Rule>, Union, Bind, Id, Unbind,
        boost::recursive_wrapper<ComposeCommon>,
        boost::recursive_wrapper<ComposeParallel>,
        boost::recursive_wrapper<ComposeSub>,
        boost::recursive_wrapper<ComposeSuper>
        > data;
    };

Class ``RCExp::ComposeBase``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: RCExp::ComposeBase
    

    The base class for the composition of two rule :math:`(L_1, K_1, R_1)` and :math:`(L_2, K_2, R_2)`.


Synopsis
^^^^^^^^

.. code-block:: c++
    
    class ComposeBase {
    protected:
        ComposeBase(Expression first, Expression second, bool discardNonchemical);
    public:
        virtual ~ComposeBase();
        friend std::ostream &operator<<(std::ostream &s, const ComposeBase &compose);
        const Expression &getFirst() const;
        const Expression &getSecond() const;
        bool getDiscardNonchemical() const;
    private:
        virtual std::ostream &print(std::ostream &s) const = 0;
    private:
        Expression first, second;
        bool discardNonchemical;
    };

Class ``RCExp::ComposeCommon``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: RCExp::ComposeCommon
    

    Compose the rules by all common subgraphs of :math:`R_1` and :math:`L_2`,
    possibly limited to connected subgraphs or to the subgraphs of maximum size.


Synopsis
^^^^^^^^

.. code-block:: c++
    
    struct ComposeCommon : public ComposeBase {
        ComposeCommon(Expression first, Expression second, bool discardNonchemical, bool maximum, bool connected);
        bool getMaxmimum() const;
        bool getConnected() const;
    private:
        std::ostream &print(std::ostream &s) const;
    private:
        bool maximum, connected;
    };

Class ``RCExp::ComposeParallel``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: RCExp::ComposeParallel
    

    Compose the rules by the empty graph, i.e., create a rule representing the parallel application of two input rules.


Synopsis
^^^^^^^^

.. code-block:: c++
    
    struct ComposeParallel : public ComposeBase {
        ComposeParallel(Expression first, Expression second, bool discardNonchemical);
    private:
        std::ostream &print(std::ostream &s) const;
    };

Class ``RCExp::ComposeSub``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: RCExp::ComposeSub
    

    Compose the rules such that overlapping connected components of :math:`R_1` and :math:`L_2` have the :math:`L_2` component as a subgraph of :math:`R_1`.
    The overlap is `partial` if not every connected component of :math:`L_2` is participating in the common subgraph.


Synopsis
^^^^^^^^

.. code-block:: c++
    
    struct ComposeSub : public ComposeBase {
        ComposeSub(Expression first, Expression second, bool discardNonchemical, bool allowPartial);
        bool getAllowPartial() const;
    private:
        std::ostream &print(std::ostream &s) const;
    private:
        bool allowPartial;
    };

Class ``RCExp::ComposeSuper``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: RCExp::ComposeSuper
    

    Compose the rules such that overlapping connected components of :math:`R_1` and :math:`L_2` have the :math:`R_1` component as a subgraph of :math:`L_2`.
    The overlap is `partial` if not every connected component of :math:`R_1` is participating in the common subgraph.


Synopsis
^^^^^^^^

.. code-block:: c++
    
    struct ComposeSuper : public ComposeBase {
        ComposeSuper(Expression first, Expression second, bool discardNonchemical, bool allowPartial, bool enforceConstraints);
        bool getAllowPartial() const;
        bool getEnforceConstraints() const;
    private:
        std::ostream &print(std::ostream &s) const;
    private:
        bool allowPartial, enforceConstraints;
    };
